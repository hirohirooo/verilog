`include "pu.vh"
module imem(input [`PCS:0] pc, output logic [`CMDS:0] o);
	always_comb
		case(pc)
		// synopsys full_case parallel_case
		6'h00: o = 16'b0000_0000_0000_0000; // NOP

		//初期値のセット
		6'h01: o = 16'b1000_00_10_0000_0001; //LIL
		6'h02: o = 16'b1000_00_11_0000_0000; //LIH r0 <- 1

		//メモリに格納
		// 0 1 0 * 1 0 b-> im------------> ; SM [(s)im]=rb *MM
		6'h03: o = 16'b010_0_10_00_0000_1111; //SM 15 <- r0

		//初期値のセット
		6'h04: o = 16'b1000_01_10_0000_0001; //LIL
		6'h05: o = 16'b1000_01_11_0000_0000; //LIH r1 <- 1

		//メモリに格納
		6'h06: o = 16'b010_0_10_01_0001_0000; //SM 16 <- r1

		//カウンタをセット
		6'h07: o = 16'b1000_11_10_0000_1110; //LIL
		6'h08: o = 16'b1000_11_11_0000_0000; //LIH r3 <- 14

		//計算
		6'h09: o = 16'b0000_10_10_0000_00_01; //r2<-a+b
		6'h0A: o = 16'b0000_10_00_0010_00_01; //r0<-r1
		6'h0B: o = 16'b0000_10_01_0010_00_10; //r1<-r2

		//メモリに格納
		// 1 0 1 1 a-> b-> im------------> ; SM [ra + (s)im]=rb
		6'h0C: o = 16'b1011_11_10_0000_0000; //SM IM[r3] <- r2

		//カウンタを1減らす
		// 0 0 1 # rw> a-> im------------> ; CAL rw=ra,im (#=0:ADD/1:SUB only)
		6'h0D: o = 16'b0011_11_11_0000_0001;

		//pc = 9 へジャンプ
		// 0 1 0 p 1 1 f f im------------> ; JP/BR fp [PC + (s)im]
		6'h0E: o = 16'b010_0_11_01_1111_1011; //補数表現-5

		//初期値をメモリに格納
		6'h0F: o = 16'b1000_00_10_0000_0000; //LIL
		6'h10: o = 16'b1000_00_11_0000_0000; //LIH r0 <- 0

		//カウンタをセット
		6'h11: o = 16'b1000_11_10_0001_0000; //LIL
		6'h12: o = 16'b1000_11_11_0000_0000; //LIH r3 <- 16

		//メモリから読み出す
		// 1 0 1 0 rw> a-> im------------> ; LM rw=[ra + (s)im]
		6'h13: o = 16'b1010_01_11_0000_0000; //LM r1 <- im[r3]

		//累積和と加算してレジスタに格納
		// 0 0 0 0 1 0 rw> F op--> a-> b-> ; CAL rw=ra,rb (F=0:NORM/1:DSTB) MV
		6'h14: o = 16'b0000_10_00_0_000_00_01; //r0 = r0 + r1

		//レジスタの累積和をメモリ0に格納
		// 0 1 0 * 1 0 b-> im------------> ; SM [(s)im]=rb *MM
		6'h15: o = 16'b010_0_10_00_0000_0000; //SM 0 <- r0

		//カウンタを1減らす
		// 0 0 1 # rw> a-> im------------> ; CAL rw=ra,im (#=0:ADD/1:SUB only)
		6'h16: o = 16'b0011_11_11_0000_0001;

		//pc = 13へジャンプ
		// 0 1 0 p 1 1 f f im------------> ; JP/BR fp [PC + (s)im]
		6'h17: o = 16'b010_0_11_01_1111_1100; //補数表現-4

		//累積和を出力する
		// 1 0 0 1 rw> * * im------------> ; LM rw=[im] *MM
		6'h18: o = 16'b1001_00_00_0000_0000;

		//終了
		6'h19: o = 0000_00_0000_0000_01;

		endcase
endmodule

// F E D C B A 9 8 7 6 5 4 3 2 1 0
// 0 0 0 0 0 0 * * * * * * * * * 0 ; NOP (0) DSTB
// 0 0 0 0 0 0 * * * * * * * * * 1 ; HALT (1)
// 0 0 0 0 0 1 * * * * * * * * * * ; future reserved (PUSH, POP, SET(reg))
// 0 0 0 0 1 0 rw> F op--> a-> b-> ; CAL rw=ra,rb (F=0:NORM/1:DSTB) MV
// 0 0 0 0 1 1 * * * op--> a-> b-> ; EVA CAL ra,rb (F=0)/CMP ra,rb
// 0 0 0 1 0 0 f f p op--> a-> b-> ; JP/BR fp [ra op rb] (ff:NC,Z,C,S)
// 0 0 0 1 0 1 * * * * * * * * * * ; future reserved
// 0 0 0 1 1 0 F * * op--> a-> b-> ; SM [ra]=rb / SM [ra] = [ra op rb] *MM
// 0 0 0 1 1 1 rw> F op--> a-> b-> ; LM rw=[ra op rb] / LM rw=[rb] *MM
// 0 0 1 # rw> a-> im------------> ; CAL rw=ra,im (#=0:ADD/1:SUB only)
// 0 1 0 p 0 * f f im------------> ; JP/BR fp [(s)im]
// 0 1 0 * 1 0 b-> im------------> ; SM [(s)im]=rb *MM
// 0 1 0 p 1 1 f f im------------> ; JP/BR fp [PC + (s)im]
// 0 1 1 -----> ; JP/BR fp [ra + (s)im]p a-> f f im-------
// 1 0 0 0 rw> 0 0 0 0 0 0 0 S C Z ; LI rw,SM S:sign C:carry Z:zero
// 1 0 0 0 rw> 0 1 im------------> ; LI rw,(s)im (rw=rb) lidx=o[9:8]
// 1 0 0 0 rw> 1 0 im------------> ; LIL rw,im (rw=rb)
// 1 0 0 0 rw> 1 1 im------------> ; LIH rw,im (rw=rb)
// 1 0 0 1 rw> * * im------------> ; LM rw=[im] *MM
// 1 0 1 0 rw> a-> im------------> ; LM rw=[ra + (s)im]
// 1 0 1 1 a-> b-> im------------> ; SM [ra + (s)im]=rb
// 1 1 * * * * * * * * * * * * * * ; future reserved *MM
//ペラン数計算用に追加
//判定条件用に直値とレジスタの値で引き算,結果の書き込みなし
// 1 1 1 1 a-> * * im------------> ; CMP ra-im (SUB)
